# 영속성 관리

JPA가 제공하는 기능은 크게 아래와 같습니다.

- 엔티티와 테이블을 매핑하는 설계 부분
- 매핑한 엔티티를 사용하는 부분

3장에서는 사용하는 부분을 먼저 살펴보겠습니다.
<br>
## 엔티티 매니저 팩토리와 엔티티 매니저

앞장에서 말한것과 같이 엔티티 매니저 팩토리와 엔티티 매니저의 특징은 아래와 같습니다.

| name | thread-safe | 생성 비용 |
| -- | -- | -- |
| entity manager factory | O | 큼 |
| entity manager | X | 작음 |


아래는 entity manager factory, entity manager 를 사용하는 일반적인 app 을 보여 줍니다.

![image](https://user-images.githubusercontent.com/31622350/96356540-ded91780-112a-11eb-9d80-eec3d7f7b0e0.png)

그림에서 알 수 있듯이 엔티티 매니저는 `DB 연결이 꼭 필요한 시점까지 커넥션을 얻지 않습니다.`

<br>

## 영속성 컨텍스트

엔티티 매니저는 `영속성 컨텍스트`라는 곳에 엔티티를 저장하고 조회합니다.
> 영속성 컨텍스트는 엔티티를 저장하는 환경으로 보시면 됩니다.

엔티티 매니저가 생성되는 시점에 영속성 컨텍스트 하나가 생성됩니다.
> 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수도 있습니다.

<br>

## 엔티티의 생명주기

엔티티에는 4가지의 상태가 존재합니다.

- 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태

아래는 위 4개의 생명주기간의 관계를 나타낸 그림입니다.

![image](https://user-images.githubusercontent.com/31622350/96356600-bbfb3300-112b-11eb-8535-084ce16b553b.png)

<br>

#### 비영속

엔티티 객체를 생성했지만, 엔티티 매니저가 관리하지 않는 초기 상태입니다.

아래 코드의 경우가 비영속 상태입니다.

```java
String id = "id1";
Member member = new Member();
member.setId(id);
member.setUsername("지한");
member.setAge(2);
```

<br>

#### 영속

엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태입니다.
> 한마디로 영속성 컨텍스트에 의해 관리되는 상태입니다.

아래 코드의 경우가 영속 상태입니다.

```java
em.persist(member);
```

<br>

#### 준영속

영속성 컨텍스트가 관리하다, 더이상 관리하지 않으면 준영속 상태입니다.

엔티티매니저를 종료( = close)하거나, 초기화( = clear)하는 경우에도 준영속 상태입니다.


<br>

#### 삭제

엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제하는 상태입니다.


<br>

## 영속성 컨텍스트의 특징

영속성 컨텍스트의 특징은 아래와 같습니다.

<br>

#### 1. 영속성 컨텍스트와 식별자 값

영속성 컨텍스트는 엔티티를 식별자 값으로 구분합니다.
> @Id 로 테이블의 기본키와 매핑한 값

따라서, 영속상태는 식별자값이 반드시 있어야 합니다.

<br>

#### 2. 영속성 컨텍스트와 데이터베이스 저장

JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영합니다.
> 이를 플러시라 합니다.

<br>

#### 3. 영속성 컨텍스트가 엔티티를 관리할 때 장점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩


<br>

### 엔티티 조회

영속성 컨텍스트는 내부에 캐시로 엔티티를 관리하는 Map을 가지고 있습니다.
> 이때, Map의 key는 @Id 로 지정한 식별자입니다.

아래 그림은 조회 시 어떤 절차로 이루어지는지 보여주는 그림입니다.

![image](https://user-images.githubusercontent.com/31622350/96356720-b0107080-112d-11eb-9ea4-dca12662e541.png)

1. 캐시에서 먼저 조회
2. 있다면 반환, 없다면 DB 조회
3. DB에서 조회한 결과 캐싱
4. 반환

이때, 캐싱 데이터를 먼저 체크하기 때문에 아래와 같은 코드는 동일한 java instance를 반환받게 됩니다.

```java
Member a = en.find(Memeber.class, "member1");
Member b = en.find(Memeber.class, "member1");

System.out.println(a==b);
```

이런 구조로 인해 개발자는 성능상 이점과 엔티티의 동일성을 보장받을 수 있습니다.

<br>

### 엔티티 등록

엔티티를 등록 절차는 아래 그림과 같이 이루어집니다.

![image](https://user-images.githubusercontent.com/31622350/96356768-3fb61f00-112e-11eb-8af1-fabcf0e182d4.png)

1. 1차 캐시에 저장
2. insert sql 생성하여 지연 SQL 저장소에 저장


그리고, 이제 트랜잭션이 끝나는 시점( = `즉, DB에 동기화 하는 시점`)에는 아래과 같이 이루어지게 됩니다.

![image](https://user-images.githubusercontent.com/31622350/96356771-45ac0000-112e-11eb-8357-57d7d33ac518.png)

1. SQL 저장소에 있는 쿼리들을 DB에 flush
2. transaction commit

이런 쓰기지연으로 인해, 개발자는 메모리상에서 데이터에 대해 CRUD를 충분히 수행 하더라도 
DB에 불필요한 작업을 일으키지 않게 됩니다.
> =성능의 최적화


<br>

### 엔티티 수정

보통 SQL 의존적인 app의 경우 테이블에 필드가 하나 추가되는 경우 아래와 같은 일들을 반복적으로 하게 됩니다.

1. sql 수정
2. 조회 시 object setting 수정
3. insert 시 object setting 수정
4. update 시 object setting 수정

하지만 JPA를 사용하게 되면 변경 감지기능으로 인해 sql의 의존적이지 않게
java 객체와 비즈니스 로직만 수정하면 됩니다.

여기서 `변경 감지 기능`은 엔티티의 변경사항을 자동으로 DB에 반영하는 것을 말합니다.

아래는 변경감지의 절차를 보여주는 그림입니다.

![image](https://user-images.githubusercontent.com/31622350/96356893-b30c6080-112f-11eb-9844-fddbad27c4e5.png)

그림에서 보면 알듯이 영속성 컨텍스트는 1차캐시에 스냅샷을 가지고 있습니다.

`스냅샷은 엔티티의 최초상태를 복사해서 저장하는 것이며,
flush 호출 시 변경된 엔티티와 스냅샷을 비교하여 update sql을 생성하게 됩니다.
`

변경 감지는 영속성 컨텍스트가 관리하는 영속상태의 엔티티에만 적용되며,
그 외 상태는 변경하더라도 DB에 반영이 되지 않습니다.


그럼, 엔티티가 변경되면 update sql은 어떻게 생성되어 질까요?

JPA는 기본으로 전체 필드에 대해서 UPDATE SQL을 생성합니다.
> 물론 변경 필드만으로도 생성되도록 옵션이 있습니다.
> @DynamicUpdate

하지만, 전체 필드로 하는 경우에는 아래와 같은 장단점이 있습니다.

| 장점 | 단점 |
| -- | -- |
| 쿼리가 동일하여 캐싱 효과( = 성능 향상 ) |  DB 적재시 데이터 전송량이 커짐 |


<br>

### 엔티티 삭제

엔티티 삭제는 remove 메서드를 호출하면 됩니다.

이때, 해당 엔티티는 DB에 바로 삭제되는것이 아니라 앞에서와 동일하게 삭제 상태로 이동만 되어집니다.


<br>

## 플러시

플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 반영함을 의미합니다.

플러시 동작 절차는 아래와 같습니다.

1. 변경 감지가 동작하여 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여 수정된 엔티티 검출 및 수정 쿼리를 쓰기 지연 저장소에 등록
2. 쓰기 지연 저장소의 쿼리를 DB에 전송

플러시하는 방법은 아래와 같습니다.

1. em.flush() 호출
2. 트랜잭션 커밋 시 플러시 자동 호출
3. JPQL 쿼리 실행 시 플러시가 자동 호출 (`식별자를 기준으로 조회하는 find()의 경우에는 호출 X`)


<br>

### 플러시 모드 옵션

플러시는 2개의 옵션을 가지고 있습니다.

- FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시( default )
- FlushModeType.COMMIT: 커밋할 때만 플러시

`주의할점: 플러시는 영속성 컨텍스트와 DB간의 동기화 작업일 뿐, 영속성 컨텍스트가 관리하는 엔티티를 지우는것이 아님.`


<br>

## 준영속

준영속이란 영속상태의 엔티티가 영속성 컨텍스트에서 분리된것을 의미합니다.
> 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하지 않기 때문에 앞에서 본 기능들을 사용할 수 없습니다.

준영속 상태로 만드는 방법은 3가지가 있습니다.

1. em.detach(entity): 특정 엔티티를 준영속 상태로 만드는 메서드
2. em.clear(): 영속성 컨텍스트를 왼전히 초기화
3. em.close(): 영속성 컨텍스트를 종료


<br>

### 엔티티를 준영속 상태로 전환: detach()

아래는 detach 메서드 호출 시 동작 절차입니다.

![image](https://user-images.githubusercontent.com/31622350/96359422-c1697500-114d-11eb-9b2c-316a4ce4d893.png)

그림에서 보이는것과 같이 엔티티를 더이상 영속 컨텍스트가 관리하지 않는 상태로 만들기 때문에
아래와 같은 동작이 수행됩니다.

- `1차 캐시 제거`
- `쓰기 지연 SQL 저장소에서 관련 SQL 제거`


<br>

### 영속성 컨텍스트 초기화: clear()

em.clear()는 영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듭니다. 

아래는 clear() 메서드 호출 후 영속성 컨텍스트가 초기화 된 그림입니다.

![image](https://user-images.githubusercontent.com/31622350/96359480-46548e80-114e-11eb-9ece-3aa9255c69e3.png)


<br>

### 영속성 컨텍스트 종료: close()

em.close()는 엔티티매니저를 아예 종료함으로써 준영속으로 만드는 것입니다.


<br>

### 준영속 상태의 특징

준영속 상태의 특징은 아래와 같습니다.

- 거의 비영속 상태에 가깝다: 영속성 컨텍스트가 관리하지 않으므로 제공하는 기능을 누릴수 없기 때문입니다.

- 식별자 값을 가지고 있다: 한번 영속 상태였던 적이 있기에 식별자 값을 가지고 있습니다.

- 지연 로딩을 할 수 없다: 지연 로딩 역시 영속성 컨텍스트를 통한 기능이기에 사용을 못합니다.

`개인적으로 준영속 상태는 더이상 관리하지 않는 엔티티  즉, java object를 gc 대상으로 잡기 위해서 존재한다고 보는것도 맞는거 같습니다.`


<br>

### 병합

병합은 준영속 상태의 엔티티를 다시 영속 상태로 변경하는것을 말합니다.

아래는 병합인 merge() 메서드 호출 시 동작 절차입니다.

![image](https://user-images.githubusercontent.com/31622350/96359597-a7309680-114f-11eb-9979-a48676a3c708.png)

그림에서 보듯이 흡사 persist와 비슷하다고 보면 됩니다.

다만, merge는 인자로 받는 엔티티가 비영속, 준영속을 따지지 않고
단지 1차 캐시에서 조회가 안되면 DB를 조회하여 캐싱한다고 보면 됩니다.
> 영속성 컨텍스트의 save or update 라고 보시면 됩니다.